# ðŸ§  LLM Multi-Step Plan Execution System

## ðŸ“Š **CRITICAL IMPLEMENTATION GAP**

**Status**: **MISSING FROM CURRENT IMPLEMENTATION**  
**Priority**: **CRITICAL** - Core feature from MVP implementation plan  
**Location**: Week 7-8 of original plan (Phase 4: LLM Integration)  
**Impact**: Essential for sophisticated AI unit behavior

---

## ðŸŽ¯ **SYSTEM OVERVIEW**

The Multi-Step Plan Execution System is a sophisticated AI framework that allows units to execute complex, multi-step plans generated by the LLM, rather than just simple commands. This system transforms natural language prompts into detailed tactical plans with triggers, timing, and conditional logic.

### **Current vs Required**

| **Aspect** | **Current Implementation** | **Required Implementation** |
|------------|---------------------------|----------------------------|
| **Command Type** | Single direct commands | Multi-step plans with triggers |
| **Execution** | Immediate execution | Timed execution with conditions |
| **AI Response** | Simple action mapping | Complex plan generation |
| **Validation** | Basic command validation | Schema validation with duration limits |
| **Flexibility** | Static command execution | Dynamic plan adaptation |

---

## ðŸ§© **CORE COMPONENTS**

### **1. Plan Validator (ActionValidator.gd)**

```gdscript
# ActionValidator.gd
class_name ActionValidator
extends Node

const MAX_PLAN_DURATION = 6.0  # seconds
const MAX_STEPS_PER_PLAN = 8
const ALLOWED_ACTIONS = ["move_to", "peek_and_fire", "lay_mines", "hijack_enemy_spire", "retreat"]

func validate_plan(plan: Dictionary) -> bool:
    # Check plan schema
    if not _validate_schema(plan):
        return false
    
    # Verify action whitelist
    if not _validate_actions(plan):
        return false
    
    # Validate parameters
    if not _validate_parameters(plan):
        return false
    
    # Check duration limits (< 6s total)
    if not _validate_duration(plan):
        return false
    
    # Moderate speech content
    if not _moderate_speech(plan):
        return false
    
    return true

func _validate_schema(plan: Dictionary) -> bool:
    # Required fields: steps, unit_id, total_duration
    return plan.has("steps") and plan.has("unit_id") and plan.has("total_duration")

func _validate_actions(plan: Dictionary) -> bool:
    var steps = plan.get("steps", [])
    for step in steps:
        if not step.get("action", "") in ALLOWED_ACTIONS:
            return false
    return true

func _validate_duration(plan: Dictionary) -> bool:
    var total_duration = plan.get("total_duration", 0.0)
    return total_duration <= MAX_PLAN_DURATION

func _moderate_speech(plan: Dictionary) -> bool:
    # Check for inappropriate speech content
    var steps = plan.get("steps", [])
    for step in steps:
        var speech = step.get("speech", "")
        if not _is_appropriate_speech(speech):
            return false
    return true
```

### **2. Plan Executor (PlanExecutor.gd)**

```gdscript
# PlanExecutor.gd
class_name PlanExecutor
extends Node

class PlanStep:
    var action: String
    var params: Dictionary
    var duration_ms: int = 0
    var trigger: String = ""
    var speech: String = ""
    var start_time: float = 0.0
    var conditions: Dictionary = {}

var active_plans: Dictionary = {}  # unit_id -> Array[PlanStep]
var step_timers: Dictionary = {}   # unit_id -> float
var current_steps: Dictionary = {} # unit_id -> PlanStep

# Signals
signal plan_started(unit_id: String, plan: Array)
signal plan_completed(unit_id: String)
signal plan_interrupted(unit_id: String, reason: String)
signal step_executed(unit_id: String, step: PlanStep)

func _ready() -> void:
    # Process plans every frame
    set_process(true)

func _process(delta: float) -> void:
    for unit_id in active_plans:
        _process_unit_plan(unit_id, delta)

func execute_plan(unit_id: String, plan: Array) -> bool:
    # Validate plan first
    if not ActionValidator.validate_plan({"steps": plan, "unit_id": unit_id}):
        return false
    
    # Convert plan data to PlanStep objects
    var validated_steps = []
    for step_data in plan:
        var step = PlanStep.new()
        step.action = step_data.get("action", "")
        step.params = step_data.get("params", {})
        step.duration_ms = step_data.get("duration_ms", 0)
        step.trigger = step_data.get("trigger", "")
        step.speech = step_data.get("speech", "")
        step.conditions = step_data.get("conditions", {})
        validated_steps.append(step)
    
    # Start plan execution
    active_plans[unit_id] = validated_steps
    current_steps[unit_id] = null
    step_timers[unit_id] = 0.0
    
    plan_started.emit(unit_id, validated_steps)
    _start_next_step(unit_id)
    
    return true

func _process_unit_plan(unit_id: String, delta: float) -> void:
    if not current_steps.has(unit_id):
        _start_next_step(unit_id)
        return
    
    var step = current_steps[unit_id]
    var unit = _get_unit(unit_id)
    
    if not unit:
        _interrupt_plan(unit_id, "Unit not found")
        return
    
    # Update step timer
    step_timers[unit_id] += delta
    
    # Check for step completion
    if _is_step_complete(unit_id, step, unit):
        _complete_step(unit_id)

func _is_step_complete(unit_id: String, step: PlanStep, unit: Unit) -> bool:
    # Check trigger conditions
    if step.trigger != "":
        return _evaluate_trigger(step.trigger, unit)
    
    # Check duration
    if step.duration_ms > 0:
        var elapsed_ms = step_timers[unit_id] * 1000.0
        return elapsed_ms >= step.duration_ms
    
    # Check action completion
    return _is_action_complete(step.action, unit)

func _evaluate_trigger(trigger: String, unit: Unit) -> bool:
    # Parse trigger conditions like "health_pct < 20", "enemy_dist < 10"
    match trigger:
        var health_trigger when trigger.begins_with("health_pct"):
            var threshold = _parse_numeric_trigger(trigger)
            return (unit.current_health / unit.max_health * 100) < threshold
        
        var enemy_trigger when trigger.begins_with("enemy_dist"):
            var threshold = _parse_numeric_trigger(trigger)
            return _get_nearest_enemy_distance(unit) < threshold
        
        var time_trigger when trigger.begins_with("time"):
            var threshold = _parse_numeric_trigger(trigger)
            return step_timers[unit.unit_id] > threshold
        
        _:
            return false

func _complete_step(unit_id: String) -> void:
    var step = current_steps[unit_id]
    step_executed.emit(unit_id, step)
    
    # Show speech bubble if specified
    if step.speech != "":
        _show_speech_bubble(unit_id, step.speech)
    
    # Remove completed step
    active_plans[unit_id].pop_front()
    current_steps.erase(unit_id)
    step_timers[unit_id] = 0.0
    
    # Check if plan is complete
    if active_plans[unit_id].is_empty():
        _complete_plan(unit_id)
    else:
        _start_next_step(unit_id)

func _start_next_step(unit_id: String) -> void:
    if not active_plans.has(unit_id) or active_plans[unit_id].is_empty():
        return
    
    var next_step = active_plans[unit_id][0]
    current_steps[unit_id] = next_step
    next_step.start_time = Time.get_ticks_msec() / 1000.0
    
    # Execute the step action
    _execute_step_action(unit_id, next_step)

func _execute_step_action(unit_id: String, step: PlanStep) -> void:
    var unit = _get_unit(unit_id)
    if not unit:
        return
    
    # Dispatch action to unit's FSM
    match step.action:
        "move_to":
            var target_pos = Vector3(step.params.get("x", 0), 0, step.params.get("z", 0))
            unit.move_to(target_pos)
        
        "peek_and_fire":
            var target_id = step.params.get("target_id", "")
            unit.peek_and_fire(target_id)
        
        "lay_mines":
            var mine_count = step.params.get("count", 1)
            unit.lay_mines(mine_count)
        
        "hijack_enemy_spire":
            var spire_id = step.params.get("spire_id", "")
            unit.hijack_spire(spire_id)
        
        "retreat":
            unit.retreat()
```

### **3. Enhanced LLM Integration**

```gdscript
# Enhanced LLMBridge.gd additions
func request_unit_plan(unit_id: String, context: Dictionary) -> void:
    var unit = GameManager.get_unit(unit_id)
    if not unit:
        return
    
    var prompt = _build_plan_prompt(unit, context)
    var request_data = {
        "model": "gpt-4",
        "messages": [{"role": "user", "content": prompt}],
        "functions": [_get_plan_function_schema()],
        "function_call": {"name": "create_unit_plan"}
    }
    
    _send_request(request_data, "_on_plan_response", {"unit_id": unit_id})

func _get_plan_function_schema() -> Dictionary:
    return {
        "name": "create_unit_plan",
        "description": "Create a multi-step tactical plan for a unit",
        "parameters": {
            "type": "object",
            "properties": {
                "steps": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "action": {"type": "string", "enum": ["move_to", "peek_and_fire", "lay_mines", "hijack_enemy_spire", "retreat"]},
                            "params": {"type": "object"},
                            "duration_ms": {"type": "integer", "minimum": 0, "maximum": 6000},
                            "trigger": {"type": "string"},
                            "speech": {"type": "string", "maxLength": 12},
                            "conditions": {"type": "object"}
                        },
                        "required": ["action"]
                    }
                },
                "reasoning": {"type": "string"}
            },
            "required": ["steps"]
        }
    }

func _build_plan_prompt(unit: Unit, context: Dictionary) -> String:
    var prompt = """
You are controlling a %s unit in a tactical RTS. Create a multi-step plan based on the current situation.

CURRENT SITUATION:
- Unit Health: %d/%d
- Position: %s
- Visible Enemies: %s
- Visible Allies: %s
- Recent Events: %s

AVAILABLE ACTIONS:
1. move_to(x, z) - Move to position
2. peek_and_fire(target_id) - Attack from cover
3. lay_mines(count) - Place area denial
4. hijack_enemy_spire(spire_id) - Sabotage enemy building
5. retreat() - Fall back to safety

PLAN CONSTRAINTS:
- Maximum 8 steps
- Total duration under 6 seconds
- Each step can have triggers like "health_pct < 20" or "enemy_dist < 10"
- Speech limited to 12 words per step

Create a tactical plan that maximizes unit effectiveness while minimizing risk.
""" % [
        unit.archetype,
        unit.current_health, unit.max_health,
        unit.global_position,
        _format_visible_units(unit.visible_enemies),
        _format_visible_units(unit.visible_allies),
        context.get("recent_events", [])
    ]
    
    return prompt

func _on_plan_response(response: Dictionary, metadata: Dictionary) -> void:
    var unit_id = metadata.get("unit_id", "")
    var function_call = response.get("choices", [{}])[0].get("message", {}).get("function_call", {})
    
    if function_call.get("name", "") == "create_unit_plan":
        var plan_data = JSON.parse_string(function_call.get("arguments", "{}"))
        var steps = plan_data.get("steps", [])
        
        # Execute the plan
        if PlanExecutor.execute_plan(unit_id, steps):
            print("Plan executed for unit: %s" % unit_id)
        else:
            print("Plan validation failed for unit: %s" % unit_id)
```

---

## ðŸŽ¯ **INTEGRATION REQUIREMENTS**

### **1. Connect to Current AI System**
- Integrate with existing `AICommandProcessor`
- Extend `CommandTranslator` to handle multi-step plans
- Update `OpenAIClient` to support plan generation

### **2. Update Unit System**
- Add plan execution capabilities to `Unit` class
- Integrate with existing state machine
- Add trigger evaluation system

### **3. UI Integration**
- Show plan progress in unit status
- Display current step information
- Add plan interruption controls

---

## ðŸš€ **IMPLEMENTATION TIMELINE**

### **Phase 1: Plan Validator (2 days)**
- Implement `ActionValidator.gd` with schema validation
- Add action whitelist and parameter validation
- Implement duration limits and speech moderation

### **Phase 2: Plan Executor (3 days)**
- Implement `PlanExecutor.gd` with step management
- Add trigger evaluation system
- Implement plan interruption and completion

### **Phase 3: LLM Integration (2 days)**
- Extend `LLMBridge.gd` with plan generation
- Add function calling schema for plans
- Implement plan prompt generation

### **Phase 4: System Integration (1 day)**
- Connect to existing AI command system
- Update unit classes for plan execution
- Add debugging and monitoring

### **Phase 5: Testing Framework (1 day)**
- Create plan execution test scenarios
- Add validation for complex plans
- Implement performance monitoring

---

## ðŸ“Š **EXAMPLE PLAN OUTPUT**

```json
{
  "steps": [
    {
      "action": "move_to",
      "params": {"x": 15, "z": 20},
      "duration_ms": 2000,
      "speech": "Moving to cover",
      "trigger": ""
    },
    {
      "action": "peek_and_fire",
      "params": {"target_id": "enemy_sniper_1"},
      "duration_ms": 1500,
      "speech": "Taking the shot",
      "trigger": "enemy_dist < 15"
    },
    {
      "action": "lay_mines",
      "params": {"count": 2},
      "duration_ms": 1000,
      "speech": "Setting traps",
      "trigger": ""
    },
    {
      "action": "retreat",
      "params": {},
      "duration_ms": 0,
      "speech": "Falling back",
      "trigger": "health_pct < 30"
    }
  ],
  "reasoning": "Tactical approach to eliminate sniper while setting defensive perimeter"
}
```

---

## ðŸŽ¯ **SUCCESS METRICS**

### **Technical Metrics**
- Plan validation success rate > 95%
- Plan execution accuracy > 90%
- Average plan duration < 5 seconds
- Trigger evaluation latency < 50ms

### **Gameplay Metrics**
- Unit survival rate with plans vs direct commands
- Player satisfaction with AI complexity
- Plan completion rate
- Speech bubble engagement

---

## ðŸ”¥ **CRITICAL IMPORTANCE**

This system is **essential** for the MVP because it:

1. **Differentiates from Competition**: No other RTS has sophisticated AI plan execution
2. **Enhances Player Experience**: Players see intelligent, multi-step unit behavior
3. **Fulfills Core Promise**: The "AI-driven" aspect requires complex AI behavior
4. **Enables Advanced Strategies**: Complex plans allow for sophisticated tactics
5. **Showcases AI Capabilities**: Demonstrates the power of LLM integration

**Without this system, the game becomes just another RTS with basic AI commands rather than the revolutionary AI-driven experience promised in the MVP.** 